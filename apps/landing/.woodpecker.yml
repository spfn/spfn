when:
  - event:
      - push
      - manual
    branch:
      - dev
      - develop
    path:
      include: ['apps/landing/**']
      exclude: ['**/*.md', 'apps/landing/.gitignore']
      on_empty: false

skip_clone: true

steps:
  - name: clone-source-repo
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "128Mi"
          limits:
            memory: "256Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      CI_REPO_CLONE_URL: ${CI_REPO_CLONE_URL}
      CI_COMMIT_SHA: ${CI_COMMIT_SHA}
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
    commands:
      - |
        echo "üîÑ Cloning source repository"
        apk add --no-cache git

        # Í≥†Ïú†Ìïú ÏûëÏóÖ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        WORK_DIR="/woodpecker/src-$CI_COMMIT_SHA"

        # ÎîîÎ≤ÑÍπÖ: URL Ï†ïÎ≥¥ Ï∂úÎ†•
        echo "üìã Debug Info:"
        echo "  CI_REPO_CLONE_URL: $CI_REPO_CLONE_URL"
        echo "  CI_COMMIT_BRANCH: $CI_COMMIT_BRANCH"
        echo "  CI_COMMIT_SHA: $CI_COMMIT_SHA"
        echo "  CI_BOT_USER: $CI_BOT_USER"
        echo "  Constructed URL: https://$CI_BOT_USER:*****@$(echo $CI_REPO_CLONE_URL | sed 's|https://||')"

        # ÏÜåÏä§ Ï†ÄÏû•ÏÜå ÌÅ¥Î°†
        git clone -b $CI_COMMIT_BRANCH --depth=1 \
          https://$CI_BOT_USER:$CI_BOT_TOKEN@$(echo $CI_REPO_CLONE_URL | sed 's|https://||') \
          $WORK_DIR/

        cd $WORK_DIR
        git checkout $CI_COMMIT_SHA || echo "Already on target commit"

        # Îã§Ïùå Ïä§ÌÖùÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Í≤ΩÎ°ú Ï†ÄÏû•
        mkdir -p /woodpecker/shared
        echo "$WORK_DIR" > /woodpecker/shared/work_dir

        echo "‚úÖ Source repository cloned successfully"
        ls -la $WORK_DIR/

  - name: clone-dockerfile-repo
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "128Mi"
          limits:
            memory: "256Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      DOCKERFILE_NAME: "nextjs.Dockerfile"
    commands:
      - |
        echo "üìÑ Cloning Dockerfile repository"
        apk add --no-cache git

        # Dockerfile Ï†ÄÏû•ÏÜå ÌÅ¥Î°†
        git clone --depth=1 \
          https://$CI_BOT_USER:$CI_BOT_TOKEN@git.superfunction.xyz/spfn-apps/dockerfiles \
          /woodpecker/dockerfiles/

        # Í≥µÏú† ÎîîÎ†âÌÜ†Î¶¨Ïóê Dockerfile Í≤ΩÎ°ú Ï†ÄÏû• (ÌôòÍ≤ΩÎ≥ÄÏàò ÏÇ¨Ïö©)
        mkdir -p /woodpecker/shared
        echo "/woodpecker/dockerfiles/$DOCKERFILE_NAME" > /woodpecker/shared/dockerfile_path

        echo "‚úÖ Dockerfile repository cloned successfully"
        ls -la /woodpecker/dockerfiles/

  - name: build-with-central-dockerfile
    image: gcr.io/kaniko-project/executor:debug
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "4Gi"
          limits:
            memory: "6Gi"
        nodeSelector:
          role: build
    environment:
      REGISTRY_HOST: git.superfunction.xyz
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      CI_COMMIT_SHA: ${CI_COMMIT_SHA}
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
    commands:
      - |
        echo "üöÄ Starting Kaniko build for Container Registry: $REGISTRY_HOST"
        echo "üì¶ Building image: $REGISTRY_HOST/$GIT_ORG/$GIT_REPO:$CI_COMMIT_BRANCH-$CI_COMMIT_SHA"

        mkdir -p /kaniko/.docker

        # Registry Ïù∏Ï¶ù ÏÑ§Ï†ï
        echo '{
          "auths": {
            "'$REGISTRY_HOST'": {
              "auth": "'$(echo -n $CI_BOT_USER:$CI_BOT_TOKEN | base64 | tr -d '\n')'"
            }
          }
        }' > /kaniko/.docker/config.json

        # ÎπåÎìú Ï†ïÎ≥¥Î•º Îã§Ïùå Ïä§ÌÖùÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Ï†ÄÏû•
        mkdir -p /woodpecker/shared
        echo "$REGISTRY_HOST/$GIT_ORG/$GIT_REPO-$APP_NAME:$CI_COMMIT_BRANCH-$CI_COMMIT_SHA" > /woodpecker/shared/image_tag
        echo "$CI_COMMIT_SHA" > /woodpecker/shared/commit_sha

        # ÌÅ¥Î°†Îêú Dockerfile ÏÇ¨Ïö©
        DOCKERFILE_PATH=$(cat /woodpecker/shared/dockerfile_path)
        WORK_DIR=$(cat /woodpecker/shared/work_dir)

        # Build contextÎäî apps/landingÎßå
        BUILD_CONTEXT="$WORK_DIR/apps/landing"

        echo "üìã Build Info:"
        echo "  Dockerfile: $DOCKERFILE_PATH"
        echo "  Context: $BUILD_CONTEXT"
        echo "  Image: $REGISTRY_HOST/$GIT_ORG/$GIT_REPO-$APP_NAME:${CI_COMMIT_BRANCH}-${CI_COMMIT_SHA}"

        # Dockerfile ÎÇ¥Ïö© ÌôïÏù∏
        echo "üìÑ Using Dockerfile:"
        head -10 $DOCKERFILE_PATH

        # Kaniko ÎπåÎìú Ïã§Ìñâ (apps/landingÎßå ÎπåÎìú)
        /kaniko/executor \
          --dockerfile=$DOCKERFILE_PATH \
          --context=$BUILD_CONTEXT \
          --destination=$REGISTRY_HOST/$GIT_ORG/$GIT_REPO-$APP_NAME:${CI_COMMIT_BRANCH}-${CI_COMMIT_SHA} \
          --build-arg CI_BOT_USER="$CI_BOT_USER" \
          --build-arg CI_BOT_TOKEN="$CI_BOT_TOKEN" \
          --cache=true \
          --cache-copy-layers \
          --cache-repo=$REGISTRY_HOST/$GIT_ORG/$GIT_REPO-$APP_NAME-cache

        echo "‚úÖ Build completed successfully!"

  - name: clone-gitops-repo
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "128Mi"
          limits:
            memory: "256Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
    commands:
      - |
        echo "üì¶ Cloning GitOps repository"
        apk add --no-cache git

        # GitOps Ï†ÄÏû•ÏÜå ÌÅ¥Î°† (Ìï¥Îãπ Î∏åÎûúÏπòÍ∞Ä ÎØ∏Î¶¨ ÏÉùÏÑ±ÎêòÏñ¥ ÏûàÏñ¥Ïïº Ìï®)
        GITOPS_PATH="/woodpecker/gitops-$GIT_ORG-$GIT_REPO"
        GITOPS_URL="https://$CI_BOT_USER:$CI_BOT_TOKEN@git.superfunction.xyz/spfn-apps/$GIT_ORG-$GIT_REPO.git"

        # Ìï¥Îãπ Î∏åÎûúÏπòÎ°ú ÌÅ¥Î°† ÏãúÎèÑ
        if git clone -b $CI_COMMIT_BRANCH --depth=1 $GITOPS_URL $GITOPS_PATH 2>/dev/null; then
          echo "‚úÖ GitOps repository cloned from branch: $CI_COMMIT_BRANCH"
        else
          echo "‚ö†Ô∏è GitOps repository branch not found: $CI_COMMIT_BRANCH"
          echo "üîß Creating branch from main..."

          # main Î∏åÎûúÏπòÎ°ú ÌÅ¥Î°†
          git clone -b main --depth=1 $GITOPS_URL $GITOPS_PATH
          cd $GITOPS_PATH

          # Git ÏïàÏ†Ñ ÎîîÎ†âÌÜ†Î¶¨ ÏÑ§Ï†ï (ÏÜåÏú†Í∂å Î¨∏Ï†ú Ìï¥Í≤∞)
          git config --global --add safe.directory $(pwd)

          # Git ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï
          git config user.name "Woodpecker CI"
          git config user.email "ci@superfunction.xyz"

          # ÏÉà Î∏åÎûúÏπò ÏÉùÏÑ± Î∞è Ìë∏Ïãú
          git checkout -b $CI_COMMIT_BRANCH
          git push -u origin $CI_COMMIT_BRANCH

          echo "‚úÖ GitOps repository branch created: $CI_COMMIT_BRANCH"
        fi

        # Ìï≠ÏÉÅ GitOps ÎîîÎ†âÌÜ†Î¶¨Î°ú Ïù¥Îèô
        cd $GITOPS_PATH
        # Git ÏÑ§Ï†ïÏùÄ Ïù¥ÎØ∏ Í∏ÄÎ°úÎ≤åÎ°ú ÏôÑÎ£åÎê®

        # Îã§Ïùå Ïä§ÌÖùÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Í≤ΩÎ°ú Ï†ÄÏû•
        echo "$GITOPS_PATH" > /woodpecker/shared/gitops_path

        echo "‚úÖ GitOps repository cloned successfully"
        ls -la $GITOPS_PATH

  - name: update-app-config
    image: alpine:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "64Mi"
          limits:
            memory: "128Mi"
        nodeSelector:
          role: build
    environment:
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      REGISTRY_HOST: git.superfunction.xyz
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
    commands:
      - |
        echo "‚öôÔ∏è Updating app configuration"
        apk add --no-cache yq

        # GitOps Í≤ΩÎ°ú ÏùΩÍ∏∞
        GITOPS_PATH=$(cat /woodpecker/shared/gitops_path)
        cd $GITOPS_PATH

        # ÎπåÎìú Ï†ïÎ≥¥ ÏùΩÍ∏∞
        IMAGE_TAG=$(cat /woodpecker/shared/image_tag)
        COMMIT_SHA=$(cat /woodpecker/shared/commit_sha)

        # values.yaml ÏÉùÏÑ± ÎòêÎäî ÏóÖÎç∞Ïù¥Ìä∏ (ApplicationSet Ìò∏Ìôò Íµ¨Ï°∞)
        touch values.yaml

        # App metadata
        yq e '.app.name = strenv(APP_NAME)' -i values.yaml
        yq e '.app.version = "'$COMMIT_SHA'"' -i values.yaml

        # Namespace (Î∏åÎûúÏπòÎ™ÖÏùò /Î•º -Î°ú Î≥ÄÌôò)
        BRANCH_SAFE=$(echo "$CI_COMMIT_BRANCH" | sed 's|/|-|g')
        yq e '.namespace = strenv(GIT_ORG) + "-" + "'$BRANCH_SAFE'"' -i values.yaml

        # Image configuration
        yq e '.image.repository = "'$(echo $IMAGE_TAG | cut -d: -f1)'"' -i values.yaml
        yq e '.image.tag = "'$CI_COMMIT_BRANCH'-'$COMMIT_SHA'"' -i values.yaml
        yq e '.image.pullPolicy = "IfNotPresent"' -i values.yaml
        # Gitea Registry ÏÑ§Ï†ï
        yq e '.giteaRegistry.enabled = true' -i values.yaml
        yq e '.giteaRegistry.server = "git.superfunction.xyz"' -i values.yaml
        yq e '.giteaRegistry.username = strenv(CI_BOT_USER)' -i values.yaml
        yq e '.giteaRegistry.password = strenv(CI_BOT_TOKEN)' -i values.yaml
        yq e '.giteaRegistry.secretName = "gitea-repo-secret"' -i values.yaml

        # ÎîîÎ≤ÑÍπÖ: values.yaml ÎÇ¥Ïö© ÌôïÏù∏
        echo "üìã Generated values.yaml content:"
        cat values.yaml

        echo "‚úÖ App configuration updated"

  - name: update-service-config
    image: alpine:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "64Mi"
          limits:
            memory: "128Mi"
        nodeSelector:
          role: build
    environment:
      BASE_HOST: "superfunction.xyz"
      HOST_POSTFIX: ""  # landing pageÎäî postfix ÏóÜÏùå
      CUSTOM_HOSTS: ""  # Ïª§Ïä§ÌÖÄ ÎèÑÎ©îÏù∏Îì§ (Í≥µÎ∞±ÏúºÎ°ú Íµ¨Î∂Ñ, Ïòà: "example.com api.example.com")
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
      PORT: 3790
      REPLICAS: 1
      REQUEST_CPU: "10m"
      REQUEST_MEMORY: "128Mi"
      LIMIT_CPU: "200m"
      LIMIT_MEMORY: "256Mi"
    commands:
      - |
        echo "üîß Updating service configuration"
        apk add --no-cache yq

        # GitOps Í≤ΩÎ°ú ÏùΩÍ∏∞
        GITOPS_PATH=$(cat /woodpecker/shared/gitops_path)
        cd $GITOPS_PATH

        # Service configuration
        yq e '.service.type = "ClusterIP"' -i values.yaml
        yq e '.service.port = env(PORT)' -i values.yaml
        yq e '.service.targetPort = env(PORT)' -i values.yaml

        # Resources and replicas (DEV ÌôòÍ≤Ω)
        yq e '.replicaCount = env(REPLICAS)' -i values.yaml
        yq e '.resources.requests.cpu = strenv(REQUEST_CPU)' -i values.yaml
        yq e '.resources.requests.memory = strenv(REQUEST_MEMORY)' -i values.yaml
        yq e '.resources.limits.cpu = strenv(LIMIT_CPU)' -i values.yaml
        yq e '.resources.limits.memory = strenv(LIMIT_MEMORY)' -i values.yaml

        # Health checks (Next.js Ï†ïÏ†Å ÏÇ¨Ïù¥Ìä∏)
        yq e '.healthCheck.enabled = true' -i values.yaml
        yq e '.healthCheck.readinessProbe.httpGet.path = "/"' -i values.yaml
        yq e '.healthCheck.readinessProbe.httpGet.port = env(PORT)' -i values.yaml
        yq e '.healthCheck.readinessProbe.initialDelaySeconds = 5' -i values.yaml
        yq e '.healthCheck.readinessProbe.periodSeconds = 10' -i values.yaml
        yq e '.healthCheck.readinessProbe.timeoutSeconds = 3' -i values.yaml
        yq e '.healthCheck.readinessProbe.successThreshold = 1' -i values.yaml
        yq e '.healthCheck.readinessProbe.failureThreshold = 3' -i values.yaml

        yq e '.healthCheck.livenessProbe.httpGet.path = "/"' -i values.yaml
        yq e '.healthCheck.livenessProbe.httpGet.port = env(PORT)' -i values.yaml
        yq e '.healthCheck.livenessProbe.initialDelaySeconds = 10' -i values.yaml
        yq e '.healthCheck.livenessProbe.periodSeconds = 30' -i values.yaml
        yq e '.healthCheck.livenessProbe.timeoutSeconds = 3' -i values.yaml
        yq e '.healthCheck.livenessProbe.successThreshold = 1' -i values.yaml
        yq e '.healthCheck.livenessProbe.failureThreshold = 3' -i values.yaml

        # Ingress (Dynamic host generation with multiple hosts support)
        yq e '.ingress.enabled = true' -i values.yaml
        yq e '.ingress.className = "traefik"' -i values.yaml

        # Traefik annotations
        yq e '.ingress.annotations."traefik.ingress.kubernetes.io/router.entrypoints" = "web,websecure"' -i values.yaml
        yq e '.ingress.annotations."traefik.ingress.kubernetes.io/router.tls.certresolver" = "letsencrypt"' -i values.yaml
        yq e '.ingress.annotations."traefik.ingress.kubernetes.io/router.middlewares" = "traefik-https-redirect@kubernetescrd"' -i values.yaml
        # Î∏åÎûúÏπòÎ™Ö ÏïàÏ†Ñ Ï≤òÎ¶¨ (/Î•º -Î°ú Î≥ÄÌôò)
        BRANCH_SAFE=$(echo "$CI_COMMIT_BRANCH" | sed 's|/|-|g')

        # Host ÏÉùÏÑ± (branch-gitorg-gitrepo-postfix.basehost)
        if [ "$CI_COMMIT_BRANCH" = "main" ]; then
          if [ -n "$HOST_POSTFIX" ] && [ "$HOST_POSTFIX" != "" ]; then
            HOST_PREFIX="$GIT_ORG-$GIT_REPO-$HOST_POSTFIX"
          else
            HOST_PREFIX="$GIT_ORG-$GIT_REPO"
          fi
        else
          if [ -n "$HOST_POSTFIX" ] && [ "$HOST_POSTFIX" != "" ]; then
            HOST_PREFIX="$BRANCH_SAFE-$GIT_ORG-$GIT_REPO-$HOST_POSTFIX"
          else
            HOST_PREFIX="$BRANCH_SAFE-$GIT_ORG-$GIT_REPO"
          fi
        fi

        # Í∏∞Î≥∏ Ìò∏Ïä§Ìä∏ ÏÑ§Ï†ï
        DEFAULT_HOST="$HOST_PREFIX.$BASE_HOST"
        yq e '.ingress.hosts[0].host = "'$DEFAULT_HOST'"' -i values.yaml
        yq e '.ingress.hosts[0].paths[0].path = "/"' -i values.yaml
        yq e '.ingress.hosts[0].paths[0].pathType = "Prefix"' -i values.yaml

        # Ïª§Ïä§ÌÖÄ Ìò∏Ïä§Ìä∏Îì§ Ï∂îÍ∞Ä
        if [ -n "$CUSTOM_HOSTS" ] && [ "$CUSTOM_HOSTS" != "" ]; then
          HOST_INDEX=1
          for custom_host in $CUSTOM_HOSTS; do
            yq e '.ingress.hosts['$HOST_INDEX'].host = "'$custom_host'"' -i values.yaml
            yq e '.ingress.hosts['$HOST_INDEX'].paths[0].path = "/"' -i values.yaml
            yq e '.ingress.hosts['$HOST_INDEX'].paths[0].pathType = "Prefix"' -i values.yaml
            HOST_INDEX=$((HOST_INDEX + 1))
          done
        fi

        echo "‚úÖ Service configuration updated"

  - name: commit-and-push
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "64Mi"
          limits:
            memory: "128Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      APP_NAME: superfunction
    commands:
      - |
        echo "üì§ Committing and pushing changes"
        apk add --no-cache git

        # GitOps Í≤ΩÎ°ú ÏùΩÍ∏∞
        GITOPS_PATH=$(cat /woodpecker/shared/gitops_path)
        cd $GITOPS_PATH

        # Git ÏïàÏ†Ñ ÎîîÎ†âÌÜ†Î¶¨ ÏÑ§Ï†ï (ÏÉàÎ°úÏö¥ Ïª®ÌÖåÏù¥ÎÑàÏù¥ÎØÄÎ°ú Îã§Ïãú ÏÑ§Ï†ï ÌïÑÏöî)
        git config --global --add safe.directory $GITOPS_PATH
        git config --global user.email "ci-bot@superfunctions.ai"
        git config --global user.name "CI Bot"

        # Ïª§Î∞ã SHA ÏùΩÍ∏∞
        COMMIT_SHA=$(cat /woodpecker/shared/commit_sha)

        echo "üîç Updated files in $APP_NAME:"
        ls -l ./

        # ÎîîÎ≤ÑÍπÖ: ÏµúÏ¢Ö values.yaml ÎÇ¥Ïö© ÌôïÏù∏ (Ïª§Î∞ã Ï†Ñ)
        echo "üìã Final values.yaml content before commit:"
        cat values.yaml

        # ArgoCD Î∏åÎûúÏπòÎ≥Ñ Î∞∞Ìè¨Î•º ÏúÑÌïú ÎßàÏª§ ÌååÏùº ÏÉùÏÑ±
        if [ "$CI_COMMIT_BRANCH" != "main" ]; then
          mkdir -p .argocd
          echo "# ArgoCD ApplicationSet Î∞∞Ìè¨ ÌôúÏÑ±Ìôî ÎßàÏª§" > .argocd/enabled
          echo "branch: $CI_COMMIT_BRANCH" >> .argocd/enabled
          echo "created: $(date -Iseconds)" >> .argocd/enabled
          git add .argocd/enabled
        fi

        git add values.yaml
        git commit -m "Deploy $APP_NAME ${COMMIT_SHA} to DEVELOPMENT" || echo "No changes"

        # ÌòÑÏû¨ Î∏åÎûúÏπòÏóê ÎßûÎäî Î∏åÎûúÏπòÎ°ú push (Î∏åÎûúÏπòÍ∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ±)
        TARGET_BRANCH="$CI_COMMIT_BRANCH"

        # ÌòÑÏû¨ Î∏åÎûúÏπòÍ∞Ä ÏõêÍ≤©Ïóê Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
        if git ls-remote --heads origin $TARGET_BRANCH | grep -q $TARGET_BRANCH; then
          echo "üì• Pulling latest from origin/$TARGET_BRANCH to rebase before push"
          git pull --rebase origin $TARGET_BRANCH || {
            echo "‚ùå git pull --rebase failed. You may need to resolve conflicts manually."
            exit 1
          }
        else
          echo "‚ö†Ô∏è Branch $TARGET_BRANCH does not exist on remote. Creating new branch."
          if [ "$TARGET_BRANCH" != "main" ]; then
            # mainÏù¥ ÏïÑÎãå Î∏åÎûúÏπòÎäî ÏÉàÎ°ú ÏÉùÏÑ±
            git checkout -b $TARGET_BRANCH 2>/dev/null || git checkout $TARGET_BRANCH
          fi
        fi

        # ÏõêÍ≤©ÏúºÎ°ú Ìë∏Ïãú
        if [ "$TARGET_BRANCH" != "main" ] && ! git ls-remote --heads origin $TARGET_BRANCH | grep -q $TARGET_BRANCH; then
          git push -u origin $TARGET_BRANCH
        else
          git push origin $TARGET_BRANCH
        fi
        echo "‚úÖ Changes committed and pushed successfully!"