when:
  - event:
      - push
      - manual
    branch:
      - main

skip_clone: true

steps:
  - name: clone-source-repo
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "128Mi"
          limits:
            memory: "256Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      CI_REPO_CLONE_URL: ${CI_REPO_CLONE_URL}
      CI_COMMIT_SHA: ${CI_COMMIT_SHA}
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
    commands:
      - |
        echo "ðŸ”„ Cloning source repository"
        apk add --no-cache git

        # ê³ ìœ í•œ ìž‘ì—… ë””ë ‰í† ë¦¬ ìƒì„±
        WORK_DIR="/woodpecker/src-$CI_COMMIT_SHA"

        # ì†ŒìŠ¤ ì €ìž¥ì†Œ í´ë¡ 
        git clone -b $CI_COMMIT_BRANCH --depth=1 \
          https://$CI_BOT_USER:$CI_BOT_TOKEN@$(echo $CI_REPO_CLONE_URL | sed 's|https://||') \
          $WORK_DIR/

        cd $WORK_DIR
        git checkout $CI_COMMIT_SHA || echo "Already on target commit"

        # ë‹¤ìŒ ìŠ¤í…ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìžˆë„ë¡ ê²½ë¡œ ì €ìž¥
        mkdir -p /woodpecker/shared
        echo "$WORK_DIR" > /woodpecker/shared/work_dir

        echo "âœ… Source repository cloned successfully"
        ls -la $WORK_DIR/

  - name: clone-dockerfile-repo
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "128Mi"
          limits:
            memory: "256Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      DOCKERFILE_NAME: "nextjs.Dockerfile"
    commands:
      - |
        echo "ðŸ“„ Cloning Dockerfile repository"
        apk add --no-cache git

        # Dockerfile ì €ìž¥ì†Œ í´ë¡ 
        git clone --depth=1 \
          https://$CI_BOT_USER:$CI_BOT_TOKEN@git.superfunction.xyz/spfn-apps/dockerfiles \
          /woodpecker/dockerfiles/

        # ê³µìœ  ë””ë ‰í† ë¦¬ì— Dockerfile ê²½ë¡œ ì €ìž¥ (í™˜ê²½ë³€ìˆ˜ ì‚¬ìš©)
        mkdir -p /woodpecker/shared
        echo "/woodpecker/dockerfiles/$DOCKERFILE_NAME" > /woodpecker/shared/dockerfile_path

        echo "âœ… Dockerfile repository cloned successfully"
        ls -la /woodpecker/dockerfiles/

  - name: build-with-central-dockerfile
    image: gcr.io/kaniko-project/executor:debug
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "4Gi"
          limits:
            memory: "6Gi"
        nodeSelector:
          role: build
    environment:
      REGISTRY_HOST: git.superfunction.xyz
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      CI_COMMIT_SHA: ${CI_COMMIT_SHA}
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
    commands:
      - |
        echo "ðŸš€ Starting Kaniko build for Container Registry: $REGISTRY_HOST"
        echo "ðŸ“¦ Building image: $REGISTRY_HOST/$GIT_ORG/$GIT_REPO:$CI_COMMIT_BRANCH-$CI_COMMIT_SHA"

        mkdir -p /kaniko/.docker

        # Registry ì¸ì¦ ì„¤ì •
        echo '{
          "auths": {
            "'$REGISTRY_HOST'": {
              "auth": "'$(echo -n $CI_BOT_USER:$CI_BOT_TOKEN | base64 | tr -d '\n')'"
            }
          }
        }' > /kaniko/.docker/config.json

        # ë¹Œë“œ ì •ë³´ë¥¼ ë‹¤ìŒ ìŠ¤í…ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìžˆë„ë¡ ì €ìž¥
        mkdir -p /woodpecker/shared
        echo "$REGISTRY_HOST/$GIT_ORG/$GIT_REPO:$CI_COMMIT_BRANCH-$CI_COMMIT_SHA" > /woodpecker/shared/image_tag
        echo "$CI_COMMIT_SHA" > /woodpecker/shared/commit_sha

        # í´ë¡ ëœ Dockerfile ì‚¬ìš©
        DOCKERFILE_PATH=$(cat /woodpecker/shared/dockerfile_path)
        WORK_DIR=$(cat /woodpecker/shared/work_dir)

        echo "ðŸ“‹ Build Info:"
        echo "  Dockerfile: $DOCKERFILE_PATH"
        echo "  Context: $WORK_DIR"

        # Dockerfile ë‚´ìš© í™•ì¸
        echo "ðŸ“„ Using Dockerfile:"
        head -10 $DOCKERFILE_PATH

        # Kaniko ë¹Œë“œ ì‹¤í–‰ (í´ë¡ ëœ Dockerfile ì‚¬ìš©)
        /kaniko/executor \
          --dockerfile=$DOCKERFILE_PATH \
          --context=$WORK_DIR \
          --destination=$REGISTRY_HOST/$GIT_ORG/$GIT_REPO:${CI_COMMIT_BRANCH}-${CI_COMMIT_SHA} \
          --build-arg CI_BOT_USER="$CI_BOT_USER" \
          --build-arg CI_BOT_TOKEN="$CI_BOT_TOKEN" \
          --cache=true \
          --cache-copy-layers \
          --cache-repo=$REGISTRY_HOST/$GIT_ORG/$GIT_REPO-cache

        echo "âœ… Build completed successfully!"

  - name: clone-gitops-repo
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "128Mi"
          limits:
            memory: "256Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
    commands:
      - |
        echo "ðŸ“¦ Cloning GitOps repository"
        apk add --no-cache git

        # GitOps ì €ìž¥ì†Œ í´ë¡  (main ë¸Œëžœì¹˜ê°€ ë°˜ë“œì‹œ ìžˆì–´ì•¼ í•¨)
        GITOPS_PATH="/woodpecker/gitops-$GIT_ORG-$GIT_REPO"
        GITOPS_URL="https://$CI_BOT_USER:$CI_BOT_TOKEN@git.superfunction.xyz/spfn-apps/$GIT_ORG-$GIT_REPO.git"

        # main ë¸Œëžœì¹˜ë¡œ í´ë¡  ì‹œë„
        if git clone -b $CI_COMMIT_BRANCH --depth=1 $GITOPS_URL $GITOPS_PATH 2>/dev/null; then
          echo "âœ… GitOps repository cloned from branch: $CI_COMMIT_BRANCH"
        else
          echo "âŒ GitOps repository branch not found: $CI_COMMIT_BRANCH"
          echo "ðŸ“ Please ensure the GitOps repository and branch exist:"
          echo "   Repository: $GITOPS_URL"
          echo "   Branch: $CI_COMMIT_BRANCH"
          exit 1
        fi

        # í•­ìƒ GitOps ë””ë ‰í† ë¦¬ë¡œ ì´ë™
        cd $GITOPS_PATH
        # Git ì„¤ì •ì€ ì´ë¯¸ ê¸€ë¡œë²Œë¡œ ì™„ë£Œë¨

        # ë‹¤ìŒ ìŠ¤í…ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìžˆë„ë¡ ê²½ë¡œ ì €ìž¥
        echo "$GITOPS_PATH" > /woodpecker/shared/gitops_path

        echo "âœ… GitOps repository setup completed"
        ls -la $GITOPS_PATH

  - name: update-app-config
    image: alpine:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "64Mi"
          limits:
            memory: "128Mi"
        nodeSelector:
          role: build
    environment:
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      REGISTRY_HOST: git.superfunction.xyz
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
    commands:
      - |
        echo "âš™ï¸ Updating app configuration"
        apk add --no-cache yq

        # GitOps ê²½ë¡œ ì½ê¸°
        GITOPS_PATH=$(cat /woodpecker/shared/gitops_path)
        cd $GITOPS_PATH

        # ë¹Œë“œ ì •ë³´ ì½ê¸°
        IMAGE_TAG=$(cat /woodpecker/shared/image_tag)
        COMMIT_SHA=$(cat /woodpecker/shared/commit_sha)

        # values.yaml ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸ (ApplicationSet í˜¸í™˜ êµ¬ì¡°)
        touch values.yaml

        # App metadata
        yq e '.app.name = strenv(APP_NAME)' -i values.yaml
        yq e '.app.version = "'$COMMIT_SHA'"' -i values.yaml

        # Namespace (ë¸Œëžœì¹˜ëª…ì˜ /ë¥¼ -ë¡œ ë³€í™˜)
        BRANCH_SAFE=$(echo "$CI_COMMIT_BRANCH" | sed 's|/|-|g')
        yq e '.namespace = strenv(GIT_ORG) + "-" + "'$BRANCH_SAFE'"' -i values.yaml

        # Image configuration
        yq e '.image.repository = "'$(echo $IMAGE_TAG | cut -d: -f1)'"' -i values.yaml
        yq e '.image.tag = "'$CI_COMMIT_BRANCH'-'$COMMIT_SHA'"' -i values.yaml
        yq e '.image.pullPolicy = "IfNotPresent"' -i values.yaml
        # Gitea Registry ì„¤ì •
        yq e '.giteaRegistry.enabled = true' -i values.yaml
        yq e '.giteaRegistry.server = "git.superfunction.xyz"' -i values.yaml
        yq e '.giteaRegistry.username = strenv(CI_BOT_USER)' -i values.yaml
        yq e '.giteaRegistry.password = strenv(CI_BOT_TOKEN)' -i values.yaml
        yq e '.giteaRegistry.secretName = "gitea-repo-secret"' -i values.yaml

        echo "âœ… App configuration updated"

  - name: update-service-config
    image: alpine:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "64Mi"
          limits:
            memory: "128Mi"
        nodeSelector:
          role: build
    environment:
      BASE_HOST: "superfunction.xyz"
      HOST_POSTFIX: ""  # landing pageëŠ” postfix ì—†ìŒ
      CUSTOM_HOSTS: ""  # ì»¤ìŠ¤í…€ ë„ë©”ì¸ë“¤ (ê³µë°±ìœ¼ë¡œ êµ¬ë¶„, ì˜ˆ: "example.com api.example.com")
      GIT_ORG: spfn
      GIT_REPO: spfn
      APP_NAME: superfunction
      CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}
      PORT: 3790
      REPLICAS: 1
      REQUEST_CPU: "10m"
      REQUEST_MEMORY: "128Mi"
      LIMIT_CPU: "200m"
      LIMIT_MEMORY: "256Mi"
    commands:
      - |
        echo "ðŸ”§ Updating service configuration"
        apk add --no-cache yq

        # GitOps ê²½ë¡œ ì½ê¸°
        GITOPS_PATH=$(cat /woodpecker/shared/gitops_path)
        cd $GITOPS_PATH

        # Service configuration
        yq e '.service.type = "ClusterIP"' -i values.yaml
        yq e '.service.port = env(PORT)' -i values.yaml
        yq e '.service.targetPort = env(PORT)' -i values.yaml

        # Resources and replicas (MAIN í™˜ê²½)
        yq e '.replicaCount = env(REPLICAS)' -i values.yaml
        yq e '.resources.requests.cpu = strenv(REQUEST_CPU)' -i values.yaml
        yq e '.resources.requests.memory = strenv(REQUEST_MEMORY)' -i values.yaml
        yq e '.resources.limits.cpu = strenv(LIMIT_CPU)' -i values.yaml
        yq e '.resources.limits.memory = strenv(LIMIT_MEMORY)' -i values.yaml

        # Health checks (Next.js ì •ì  ì‚¬ì´íŠ¸)
        yq e '.healthCheck.enabled = true' -i values.yaml
        yq e '.healthCheck.readinessProbe.httpGet.path = "/"' -i values.yaml
        yq e '.healthCheck.readinessProbe.httpGet.port = env(PORT)' -i values.yaml
        yq e '.healthCheck.readinessProbe.initialDelaySeconds = 5' -i values.yaml
        yq e '.healthCheck.readinessProbe.periodSeconds = 10' -i values.yaml
        yq e '.healthCheck.readinessProbe.timeoutSeconds = 3' -i values.yaml
        yq e '.healthCheck.readinessProbe.successThreshold = 1' -i values.yaml
        yq e '.healthCheck.readinessProbe.failureThreshold = 3' -i values.yaml

        yq e '.healthCheck.livenessProbe.httpGet.path = "/"' -i values.yaml
        yq e '.healthCheck.livenessProbe.httpGet.port = env(PORT)' -i values.yaml
        yq e '.healthCheck.livenessProbe.initialDelaySeconds = 10' -i values.yaml
        yq e '.healthCheck.livenessProbe.periodSeconds = 30' -i values.yaml
        yq e '.healthCheck.livenessProbe.timeoutSeconds = 3' -i values.yaml
        yq e '.healthCheck.livenessProbe.successThreshold = 1' -i values.yaml
        yq e '.healthCheck.livenessProbe.failureThreshold = 3' -i values.yaml

        # Ingress (Dynamic host generation with multiple hosts support)
        yq e '.ingress.enabled = true' -i values.yaml
        # ë¸Œëžœì¹˜ëª… ì•ˆì „ ì²˜ë¦¬ (/ë¥¼ -ë¡œ ë³€í™˜)
        BRANCH_SAFE=$(echo "$CI_COMMIT_BRANCH" | sed 's|/|-|g')

        # Host ìƒì„± (branch-gitorg-gitrepo-postfix.basehost)
        if [ "$CI_COMMIT_BRANCH" = "main" ]; then
          if [ -n "$HOST_POSTFIX" ] && [ "$HOST_POSTFIX" != "" ]; then
            HOST_PREFIX="$GIT_ORG-$GIT_REPO-$HOST_POSTFIX"
          else
            HOST_PREFIX="$GIT_ORG-$GIT_REPO"
          fi
        else
          if [ -n "$HOST_POSTFIX" ] && [ "$HOST_POSTFIX" != "" ]; then
            HOST_PREFIX="$BRANCH_SAFE-$GIT_ORG-$GIT_REPO-$HOST_POSTFIX"
          else
            HOST_PREFIX="$BRANCH_SAFE-$GIT_ORG-$GIT_REPO"
          fi
        fi

        # ê¸°ë³¸ í˜¸ìŠ¤íŠ¸ ì„¤ì •
        DEFAULT_HOST="$HOST_PREFIX.$BASE_HOST"
        yq e '.ingress.hosts[0].host = "'$DEFAULT_HOST'"' -i values.yaml
        yq e '.ingress.hosts[0].paths[0].path = "/"' -i values.yaml
        yq e '.ingress.hosts[0].paths[0].pathType = "Prefix"' -i values.yaml

        # ì»¤ìŠ¤í…€ í˜¸ìŠ¤íŠ¸ë“¤ ì¶”ê°€
        if [ -n "$CUSTOM_HOSTS" ] && [ "$CUSTOM_HOSTS" != "" ]; then
          HOST_INDEX=1
          for custom_host in $CUSTOM_HOSTS; do
            yq e '.ingress.hosts['$HOST_INDEX'].host = "'$custom_host'"' -i values.yaml
            yq e '.ingress.hosts['$HOST_INDEX'].paths[0].path = "/"' -i values.yaml
            yq e '.ingress.hosts['$HOST_INDEX'].paths[0].pathType = "Prefix"' -i values.yaml
            HOST_INDEX=$((HOST_INDEX + 1))
          done
        fi

        echo "âœ… Service configuration updated"

  - name: commit-and-push
    image: alpine/git:latest
    backend_options:
      kubernetes:
        resources:
          requests:
            memory: "64Mi"
          limits:
            memory: "128Mi"
        nodeSelector:
          role: build
    environment:
      CI_BOT_USER: { from_secret: CI_BOT_USER }
      CI_BOT_TOKEN: { from_secret: CI_BOT_TOKEN }
      APP_NAME: superfunction
    commands:
      - |
        echo "ðŸ“¤ Committing and pushing changes"
        apk add --no-cache git

        # GitOps ê²½ë¡œ ì½ê¸°
        GITOPS_PATH=$(cat /woodpecker/shared/gitops_path)
        cd $GITOPS_PATH

        # Git ì•ˆì „ ë””ë ‰í† ë¦¬ ì„¤ì • (ìƒˆë¡œìš´ ì»¨í…Œì´ë„ˆì´ë¯€ë¡œ ë‹¤ì‹œ ì„¤ì • í•„ìš”)
        git config --global --add safe.directory $GITOPS_PATH
        git config --global user.email "ci-bot@superfunctions.ai"
        git config --global user.name "CI Bot"

        # ì»¤ë°‹ SHA ì½ê¸°
        COMMIT_SHA=$(cat /woodpecker/shared/commit_sha)

        echo "ðŸ” Updated files in $APP_NAME:"
        ls -l ./

        # ArgoCD ë¸Œëžœì¹˜ë³„ ë°°í¬ë¥¼ ìœ„í•œ ë§ˆì»¤ íŒŒì¼ ìƒì„± (mainì€ ë¶ˆí•„ìš”í•˜ì§€ë§Œ ë‹¤ë¥¸ ë¸Œëžœì¹˜ëŠ” í•„ìš”)
        if [ "$CI_COMMIT_BRANCH" != "main" ]; then
          mkdir -p .argocd
          echo "# ArgoCD ApplicationSet ë°°í¬ í™œì„±í™” ë§ˆì»¤" > .argocd/enabled
          echo "branch: $CI_COMMIT_BRANCH" >> .argocd/enabled
          echo "created: $(date -Iseconds)" >> .argocd/enabled
          git add .argocd/enabled
        fi

        git add values.yaml
        git commit -m "Deploy $APP_NAME ${COMMIT_SHA} to PRODUCTION" || echo "No changes"

        # í˜„ìž¬ ë¸Œëžœì¹˜ì— ë§žëŠ” ë¸Œëžœì¹˜ë¡œ push (ìŠ¤ë§ˆíŠ¸ ë¸Œëžœì¹˜ ì²˜ë¦¬)
        TARGET_BRANCH="$CI_COMMIT_BRANCH"

        # í˜„ìž¬ ë¸Œëžœì¹˜ê°€ ì›ê²©ì— ì¡´ìž¬í•˜ëŠ”ì§€ í™•ì¸
        if git ls-remote --heads origin $TARGET_BRANCH | grep -q $TARGET_BRANCH; then
          echo "ðŸ“¥ Pulling latest from origin/$TARGET_BRANCH to rebase before push"
          git pull --rebase origin $TARGET_BRANCH || {
            echo "âŒ git pull --rebase failed. You may need to resolve conflicts manually."
            exit 1
          }
        else
          echo "âš ï¸ Branch $TARGET_BRANCH does not exist on remote. Creating new branch."
          # mainì´ ì•„ë‹Œ ë¸Œëžœì¹˜ì˜ ê²½ìš° ìƒˆ ë¸Œëžœì¹˜ ìƒì„±
          if [ "$TARGET_BRANCH" != "main" ]; then
            git checkout -b $TARGET_BRANCH 2>/dev/null || git checkout $TARGET_BRANCH
          fi
        fi

        git push -u origin $TARGET_BRANCH
        echo "âœ… Changes committed and pushed successfully to $TARGET_BRANCH!"