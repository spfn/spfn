/**
 * Client Code Generator
 *
 * Generates type-safe API client code from route-contract mappings
 */

import { mkdir, writeFile } from 'fs/promises';
import { dirname } from 'path';
import { groupByResource } from './route-scanner.js';
import type { ClientGenerationOptions, GenerationStats, RouteContractMapping } from './types.js';

/**
 * Generate API client code
 */
export async function generateClient(
    mappings: RouteContractMapping[],
    options: ClientGenerationOptions
): Promise<GenerationStats>
{
    const startTime = Date.now();

    // Group by resource
    const grouped = groupByResource(mappings);
    const resourceNames = Object.keys(grouped);

    // Generate code
    const code = generateClientCode(mappings, grouped, options);

    // Ensure output directory exists
    await mkdir(dirname(options.outputPath), { recursive: true });

    // Write file
    await writeFile(options.outputPath, code, 'utf-8');

    // Calculate stats
    return {
        routesScanned: mappings.length,
        contractsFound: mappings.length,
        contractFiles: countUniqueContractFiles(mappings),
        resourcesGenerated: resourceNames.length,
        methodsGenerated: mappings.length,
        duration: Date.now() - startTime
    };
}

/**
 * Generate the actual client code
 */
function generateClientCode(
    mappings: RouteContractMapping[],
    grouped: Record<string, RouteContractMapping[]>,
    options: ClientGenerationOptions
): string
{
    let code = '';

    // Header
    code += generateHeader();

    // Imports
    code += generateImports(mappings, options);

    // API object
    code += generateApiObject(grouped, options);

    // Footer
    code += generateFooter();

    return code;
}

/**
 * Generate file header
 */
function generateHeader(): string
{
    return `/**
 * Auto-generated API Client
 *
 * Generated by @spfn/core codegen
 * DO NOT EDIT MANUALLY
 *
 * @generated ${new Date().toISOString()}
 */

`;
}

/**
 * Generate imports section
 */
function generateImports(mappings: RouteContractMapping[], options: ClientGenerationOptions): string
{
    let code = '';

    code += `import { client } from '@spfn/core/client';\n`;

    if (options.includeTypes !== false)
    {
        code += `import type { InferContract } from '@spfn/core';\n`;
    }

    code += `\n`;

    // Contract imports (group by import path)
    const importGroups = groupContractsByImportPath(mappings);
    const importPaths = Object.keys(importGroups);

    for (let i = 0; i < importPaths.length; i++)
    {
        const importPath = importPaths[i];
        const contracts = importGroups[importPath];

        code += `import { ${contracts.join(', ')} } from '${importPath}';\n`;
    }

    code += `\n`;

    return code;
}

/**
 * Group contracts by their import path
 */
function groupContractsByImportPath(mappings: RouteContractMapping[]): Record<string, string[]>
{
    const groups: Record<string, Set<string>> = {};

    for (let i = 0; i < mappings.length; i++)
    {
        const mapping = mappings[i];
        const path = mapping.contractImportPath;

        if (!groups[path])
        {
            groups[path] = new Set();
        }

        groups[path].add(mapping.contractName);
    }

    // Convert Set to Array
    const result: Record<string, string[]> = {};
    const keys = Object.keys(groups);

    for (let i = 0; i < keys.length; i++)
    {
        const key = keys[i];
        result[key] = Array.from(groups[key]);
    }

    return result;
}

/**
 * Generate API object with all methods
 */
function generateApiObject(
    grouped: Record<string, RouteContractMapping[]>,
    options: ClientGenerationOptions
): string
{
    let code = '';

    code += `/**
 * Type-safe API client
 */
export const api = {\n`;

    const resourceNames = Object.keys(grouped);

    for (let i = 0; i < resourceNames.length; i++)
    {
        const resourceName = resourceNames[i];
        const routes = grouped[resourceName];

        code += `    ${resourceName}: {\n`;

        for (let j = 0; j < routes.length; j++)
        {
            const route = routes[j];
            code += generateMethodCode(route, options);
        }

        code += `    }`;

        if (i < resourceNames.length - 1)
        {
            code += `,`;
        }

        code += `\n`;
    }

    code += `} as const;\n\n`;

    return code;
}

/**
 * Generate a single method
 */
function generateMethodCode(mapping: RouteContractMapping, options: ClientGenerationOptions): string
{
    const methodName = generateMethodName(mapping);
    const contractType = `typeof ${mapping.contractName}`;
    const hasParams = mapping.path.includes(':');
    const hasQuery = false; // TODO: detect from contract
    const hasBody = ['POST', 'PUT', 'PATCH'].indexOf(mapping.method) !== -1;

    let code = '';

    // JSDoc
    if (options.includeJsDoc !== false)
    {
        code += `        /**\n`;
        code += `         * ${mapping.method} ${mapping.path}\n`;
        code += `         */\n`;
    }

    // Method signature
    code += `        ${methodName}: (`;

    // Parameters
    const params: string[] = [];

    if (hasParams)
    {
        params.push(`params: InferContract<${contractType}>['params']`);
    }

    if (hasQuery)
    {
        params.push(`query?: InferContract<${contractType}>['query']`);
    }

    if (hasBody)
    {
        params.push(`body: InferContract<${contractType}>['body']`);
    }

    if (params.length > 0)
    {
        code += `options: { ${params.join(', ')} }`;
    }

    code += `) => `;

    // Return type
    code += `client.call(${mapping.contractName}`;

    if (params.length > 0)
    {
        code += `, options`;
    }

    code += `),\n`;

    return code;
}

/**
 * Generate method name from route
 */
function generateMethodName(mapping: RouteContractMapping): string
{
    const method = mapping.method.toLowerCase();

    // For index routes
    if (mapping.path === '/' || mapping.path.match(/^\/[\w-]+$/))
    {
        // Simple path like /users -> get, create, update
        if (method === 'get')
        {
            return 'list';
        }
        if (method === 'post')
        {
            return 'create';
        }
    }

    // For dynamic routes like /users/:id
    if (mapping.path.includes(':'))
    {
        if (method === 'get')
        {
            return 'getById';
        }
        if (method === 'put' || method === 'patch')
        {
            return 'update';
        }
        if (method === 'delete')
        {
            return 'delete';
        }
    }

    // Default: method name
    return method;
}

/**
 * Generate footer
 */
function generateFooter(): string
{
    return `/**
 * Export client instance for advanced usage
 *
 * Use this to add interceptors or customize the client:
 *
 * @example
 * \`\`\`ts
 * import { client } from './api';
 * import { createAuthInterceptor } from '@spfn/auth/nextjs';
 * import { NextJSCookieProvider } from '@spfn/auth/nextjs';
 *
 * client.use(createAuthInterceptor({
 *   cookieProvider: new NextJSCookieProvider(),
 *   encryptionKey: process.env.ENCRYPTION_KEY!
 * }));
 * \`\`\`
 */
export { client };
`;
}

/**
 * Count unique contract files
 */
function countUniqueContractFiles(mappings: RouteContractMapping[]): number
{
    const files = new Set<string>();

    for (let i = 0; i < mappings.length; i++)
    {
        if (mappings[i].contractFile)
        {
            files.add(mappings[i].contractFile as string);
        }
    }

    return files.size;
}